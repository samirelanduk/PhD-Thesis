%%%% MACRO DEFINITION %%%%

\providecommand{\pvivax}{P.~vivax}
\providecommand{\pfalciparum}{P.~falciparum}
\providecommand{\cterm}{C-terminus}
\providecommand{\nterm}{N-terminus}

\providecommand{\e}[1]{\ensuremath{\times 10^{#1}}}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}

\providecommand{\refimage}[1]{\figurename~\ref{fig:#1}}

%TC:macro \note [ignore]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%													BEGIN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{ZincBind - The Database of Zinc Binding Sites} % Write in your own chapter title
\label{Chapter3}
\lhead{Chapter 3. \emph{ZincBind - The Database of Zinc Binding Sites}} % Write in your own chapter title to set the page header

This project is an attempt to develop novel means of predicting Zinc Binding Sites using the known properties of previously identified Zinc Binding Sites. As such, the initial step was to create a dataset of these already known sites.

This is an undertaking that has been performed previously - several times (see Chapter 1). One of the primary reasons that the effort has been duplicated so many times is because in none of the previous dataset generations did the authors make their data publicly available in an easy-to-use resource. Therefore from the very beginning of this project, the intention was always to not \emph{just} create this dataset of Zinc Binding Sites, but to make this database publicly available via a web resource, that would be continually updated with new sites as they become available.

This chapter will describe the creation of that dataset, and the web application that offers users access to the data - ZincBind.

\section{Data Generation}

ZincBind uses as its primary data source the Protein Databank \note{cite}. This contains hundreds of thousands of protein structures, a subset of which contain zinc atoms and which can be inspected to see if a zinc binding site can be identified.

The RCSB web services allow a user to query the entire databank by, among other things, the chemical formulae of its small molecules. The PDB IDs of all zinc atom containing structures can therefore be obtained by issuing a request to these web services for a \verb|ChemCompFormulaQuery| with the formula \verb|Zn|.

If the dataset is being created from scratch, each of these PDB IDs is iterated through in turn to look for zinc binding sites. If the dataset is merely being updated with new structures, only those IDs that don't already exist in the database are used.

\subsection{Structure Inspection}

The algorithm iterates through each PDB code and for each attempts to determine what zinc binding sites are present, if any, and saves the relevant objects to the database once its analysis is complete.

Each PDB ID is analysed within a single database transaction, meaning that the SQL statements are built up by Django throughout the analysis and then executed all at once at the end of each PDB ID analysis. This has two benefits. Firstly, it makes the whole process much faster - there are database records for each atom in the binding site, so opening up database connections, creating a record, and closing the connection multiple times per structure is much more time consuming than just doing that once at the end. Secondly, and more importantly, if the program is interrupted in the middle of building a database, it will essentially rollback to the last fully processed PDB, rather than saving records for half-processed PDBs which could cause errors when the program is restarted.

The structures are requested from the RCSB web servers in the .cif file format. This, and all subsequent structure parsing and analysis, are abstracted into the atomium Python library (see Appendix A).

The first processing step with the obtained and parsed structure, is to generate a biological assembly. The raw coordinates of the PDB structure contain the `asymmetric unit', which is often not the way the chains are arranged outside of the crystallisation experiment. Each PDB structure contains a list of possible biological assemblies that can be created from the chains in the asymmetric unit to make a more biologically realistic structure, and each is associated with a list of transformation matrices and calculated metrics. The delta free energy of the assemblies are used to rank them, and the lowest delta free energy assembly that still contains zinc is selected as the `real' biological assembly.

This step is critical. While asymmetric units are perfectly suitable if you are merely concerned with intra-chain features, they are often unsuitable for examining the interfaces between chains. Since many zinc binding sites are between chains, relying on asymmetric units would produce data that is not particularly meaningful.

However it is important to keep in mind that, necessary though biological assembly generation is, it does introduce some problems. Many assembly instructions are simply to get a subset of the chains in the asymmetric unit, which is fine, but some require copies of chains to be created. For example, a structure that starts out with an A chain and a B chain may in its biological assembly have two A chains and two B chains. As there is no established protocol for generating new IDs for these chains (and since creating one would create inconsistencies with other software that uses the data in the ZincBind database, such as the NGL protein viewer), the solution used here is simply to have multiple chains with the same ID. This can cause a number of problems which will be outlined, along with their solution, as they arise in this section.

Once the correct model has been generated, the algorithm then checks that the resultant structure is usable, and is not just alpha carbons as some older structures are. If it is a `skeleton structure', the zinc atom(s) in that structure are saved to the database with an annotation explaining that they don't have a binding site because the PDB was unusable. Note that this is the case whenever a zinc atom is rejected - it is still saved to the database with an explanatory annotation, because by doing this \emph{every} zinc atom in the Protein Data Bank can be accounted for in ZincBind. If this were not done, and a user tried to find a particular zinc atom from the data bank in ZincBind which had not been assigned a binding site, that user would have no way of knowing if the zinc atom was absent because ZincBind had not examined that PDB, or if it was absent because a binding site could not be assigned to it.

Any zinc atoms that are in the asymmetric unit but not the biological assembly (common in cases where the asymmetric unit is just the biological assembly repeated multiple times) are also saved to the database without a binding site, with an explanatory explanation as to why it has none, for the same reason.

The next step is to actually identify all of the binding sites. This is done as follows:

\begin{enumerate}
   \item Identify all metals in the structure. This is done using element names in atomium, but it is here that the first biological assembly related awkwardness must be dealt with. When these assemblies are being generated, sometimes atoms end up superimposed on top of each other - so called `special position' atoms. The correct interpretation of this is that there is just one atom here, not multiple occupying the same position in space, so duplicates have to be removed. This is done by taking all atoms of a given element, comparing it with every other atom of that element, and if the distance between is less than 1~{\AA}, one is removed.
   \item Determine the atoms which ligand each metal in the structure. All atoms within 3~{\AA} of the metal which aren't carbon or hydrogen are determined, and again duplicated atoms must be removed from these using the same algorithm as above (insulin structures for example, often have a chloride ligand which would appear multiple times in the same location otherwise). Once this `cloud' of suitable liganding atoms is obtained, they are ordered by distance to the metal, and for each one a check is made that the angle formed between it, the metal, and any closer atom is not less than 45$^\circ$. If it is, the atom is removed from the set of liganding atoms as it is assumed a coordinate bond would be infeasible if there is another coordinate bond so close.
   \item Remove metals that probably aren't physiologically relevant. Sometimes a metal atom in a model is just there as a consequence of the crystallisation environment, and while it may interact with one or two residues, those residues might not be a `real' zinc binding site in the sense of being an evolutionarily selected combination of residues there specifically to bind zinc. There is no way to identify with certainty which category a given zinc atom falls into from atom coordinates alone, but ZincBind implements a filter whereby if a metal atom has fewer than three main chain liganding atoms, it is discarded as probably irrelevant. Again, those atoms which are excluded at this stage are given an annotation explaining the reason, if they are zinc atoms.
   \item Merge the metals into single binding sites where necessary. So far, all metals have been considered in isolation, though in reality some of them may form co-functional units with each other. To determine if this is the case, the residues/ligands that the liganding atoms are part of are examined and, if two metals share a residue/ligand, they are assigned to the same `cluster'.
   \item Deal with duplicate binding sites. At this point another biological assembly related problem must be dealt with. There may be binding sites within the structure that are just duplicates of each other, arising from the copying done during assembly formation. The simplest way to deal with this would be to do nothing, and save each duplicate to the database as its own distinct binding site. For example PDB 1EJ6 contains the Reovirus structure, and contains sixty zinc binding sites. However these sites are all duplicates of one zinc binding site in the asymmetric unit, with identical IDs for zinc, residues and chains. Even though saving sixty different records to the database would be a prefectly accurate representation of biological reality, in practice there is no way to uniquely identify each one, so instead only one is saved, and the number of copies it has is recorded.
   \item Remove non-zinc binding sites. ZincBind is a database of \emph{zinc} binding sites. So far all metals have been considered because some non-zinc atoms may be part of a multi-metal site that contains zinc, so had to be included at every step. However now that the fully processed sites have been generated, those that don't contain zinc can be removed.
\end{enumerate}

Now that the zinc binding sites have been identified, they can be saved to the database. Before this is done however, the chain objects are saved to the database, as these records will be needed when the sites are saved. Any chain in the structure with a residue that is part of a binding site is saved. The sequence used is the full canonical sequence listed in the header of the file, not the actual sequence of residues in the model, which may contain missing residues. These two sequences are aligned using the Smith-Waterman global alignment algorithm \note{cite} so that the liganding residues in the model can be identified in the full sequence, and capitalised. The `spacers' in the sequence are also stored - the pattern of gaps between liganding residues.

\emph{Then} the sites themselves are saved to the database, along with records for any metals, residues, and residue atoms. So-called `Chain-Site Interactions' are also saved, which are essentially chains from the point of view of a particular site. While the plain chain objects saved above have residues involved in any binding site highlighted, here only the residues involved in that particular site are. This is important as chains may be involved in multiple sites, but predictive models need to know which residues contribute to \emph{single} sites.

\subsection{Equivalent Sites}

The database as it stands at this point in the algorithm will be a list of zinc binding sites, where each site is considered distinct and separate from all others. This is somewhat misleading, as many proteins appear in the Protein Data Bank several times, and so the binding site(s) in those structures will appear in ZincBind several times. The binding site in (for example) Carbonic Anhydrase will appear in ZincBind many hundreds of times, yet each of these records refer to the same biological unit.

To account for this, ZincBind clusters binding sites into equivalent sites. The first step is to cluster the zinc binding chains that were saved as part of the earlier generation process into clusters on 90\% sequence identity, using the program CD-HIT \note{cite}. It is assumed that chains in a chain cluster are functionally equivalent.

The binding sites themselves are then clustered using these chain clusters. Two zinc binding sites are assigned to the same cluster if (1) they are associated with the same chain cluster(s), (2) they have the same residue names in the same order, and (3) their surrounding residue names are the same. These latter two steps are important to ensure that chains with two or more zinc binding sites along them don't have those binding sites incorrectly assigned to the same cluster.

Finally, one site in each cluster is flagged as being `representative'. This is so that analysis that requires only one zinc binding site from each cluster is easier, and the site chosen is the site from the lowest resolution structure.

\section{The ZincBind Web Resource}

As already noted, the creation of this dataset was intended to serve both as the primary dataset of this project, and as a publicly available resource.

This resource is called ZincBind, and is accessible at \url{zincbind.bioinf.org.uk}. The website is created with Django, a Python web framework and Object Relational Management system.

The web frontend is designed with a responsive, mobile-first layout that adapts to different screen sizes, and modern JavaScript and Test Driven Development practices.

The home page contains a short, clear statement of what ZincBind is (a ``database of zinc binding sites, automatically generated from the Protein Data Bank") as well as a brief overview of its key metrics - number of unique binding sites, total number of binding sites, and the number of PDB files the sites are derived from.

Searching of the database can be done in one of three ways. Firstly, from the home page, the user can enter a search term that will be used to search multiple PDB fields at once - title, PDB code, classification etc. This is for users who just want to find entries that have any relation to a given term at all. Secondly, the user can navigate to the Advanced Search page, where they can specify a more precise search by one or more fields. This also allows searching by numeric cutoffs, such as for PDBs below a certain resolution or deposited after a certain date. Thirdly, they can provide a sequence and BLAST search the database. This uses the NCBI blastp binary on the backend, whose JSON output is processed by Django.

The search results for the first two modes of searching are returned as a list of matching PDBs, with binding sites nested within them. Both the PDB and the sites themselves are clickable and will take the user to the page for that entity. Search results can be sorted by a variety of metrics, and are paginated to 25 results per page.

PDB pages represent PDB records. They provide basic information for that PDB, as well as overviews of the zinc content of that PDB. The zincs associated with a binding site are listed as clickable links, while those without a binding site are listed along with their omission reason. Finally, there is a 3D manipulatable view of the PDB with all of its zinc binding sites. This uses the NGL JavaScript library.

The binding site pages contain more detail for that specific binding site, such as its mode of coordination, and links to equivalent sites in the same cluster. There is also a 3D manipulatable model of the binding site on this page, zoomed in to the specific site and with selectable individual residues and metals.

ZincBind also has a page that gives an overview of the dataset as a whole. This contains charts for residue distribution, experimental methods, residue codes, resolution, species frequency, and PDB classification. There are also buttons for downloading the entire dataset in either JSON or SQlite, a link to browse the entire dataset PDB by PDB, and a link to the API.

ZincBind's API is a web browsable REST API, created using the Django Rest Framework. Web browsability means that results will be returned as HTML if requests are sent using a browser, and JSON otherwise. The API can be used to get JSON representations of object sets, individual objects, and to search the database using all the same parameters as the browser search tool.

Finally, ZincBind has a help page, structured as a series of questions that a user may have.

\subsection{Web-Based Prediction}

The ZincBind website has a webpage through which users may submit `jobs' for prediction - they can upload either a structure file or a sequence, and the server will analyse them and try to ascertain if they contain any zinc binding residues.

The details of these predictive algorithms will be explained in the following chapters, but from a web development perspective, the overall architecture of how these jobs are submitted and presented to the user can be outlined here.

On the prediction page, the user is prompted to provide the representation of a protein - either as a structure file, a sequence file, or a FASTA sequence pasted in. This is done via a HTML form, and as soon as the page loads a hidden input with the job ID is generated. This is just the current time in milliseconds, making it extremely unlikely that any two jobs would have the same ID given the niche area of Biology the tool is for.

As soon as the data is given, and before the form is actually submitted, the data in question is stored to the browser's local storage using the job ID that was generated when the page loaded. This is because on the next page, this data will be used to give the user a visualisation of the data in question, and downloading it from the server when it has just been uploaded from the local machine would be a waste of bandwidth.

Once the user submits the form, the server receives the datafile, and job ID, and the django application starts the analysis process. It creates a folder in the jobs directory with the job ID's name, puts the uploaded file there, and then runs the predict.py script on it. This script is a general purpose script which takes any submitted file, and calls other predictive tools created in this PhD on it. Crucially though, this is called as an asynchronous process, so the request/response cycle doesn't have to wait for it to complete. Once the process is started, the user is redirected to the page for this particular job.

This page uses the data in local storage to show the user what they have submitted (using the NGL protein viewer for structures \note{and for sequences?}) along with a suitable `this protein is being searched' animation. The page the constantly polls the server with AJAX requests for progress updates on the job (with ever increasing periods of time between requests). The script writes its progress to a log file, which the server answers the AJAX requests with - these are then formatted and presented to the user.

\note{Explain how found binding sites are shown.}


\section{Data Analysis}

The finished dataset offers a useful insight into the general properties of zinc binding sites - or at least, that subset of zinc binding sites for which structural information is available. Some of these properties are of use to building predictive models of zinc binding sites, whereas others are of more general interest. An overview of the main findings that can be gleaned from the dataset will be presented here. All values are correct at the time of writing ({\today}), though as this is a continually and automatically updated dataset, the precise values will vary slightly as time goes on. It is not anticipated that these changes will alter the overall conclusions, as the dataset is very large already.

\emph{Note that much of this text has previously appeared in the ZincBind publication from January 2019}

\subsection{The Prevalence of Zinc}

Of the 146,856 PDB structures in the Protein Data Bank at the time of the most recent database update, 14,099 contained at least one zinc atom and are accounted for in ZincBind. This porportion - 9.60\% - is very close to the 10\% of human proteins usually said to contain zinc \note{cite}, though as the Data Bank does not purport to be representative sampling of any genome, human or otherwise, there was no particular reason for this to be the case.

\subsection{Qualifying Atoms}

In total, when run in December 2018, ZincBind identifies 41,789 zinc atoms and 1,249 other metal atoms associated with zinc atoms when searching the raw coordinates of the PDB asymmetric units. Other metals are only stored in ZincBind if they are part of a multi-metal binding site with at least one zinc atom, so the vast majority of metals in the database are zinc. Of the non-zinc metals, the most common of these `co-active' metals are magnesium, potassium, iron and copper.

Of the 41,789 zinc atoms in the database, 14,360 (34.3\%) are not associated with any binding site, and are in the database solely to acknowledge their existence. The most common reason for not assigning a zinc atom to a binding site is that the atom is duplicated multiple times in the asymmetric unit, but appears only once in the biological assembly used for processing - 9691 metals were excluded for this reason. For example, PDB entry 1A4L contains four chains, each with one zinc atom, but the biological assembly only uses one. The other three are stored in ZincBind with an omission reason, but have no binding site assigned to them.

Using the full biological assembly leads to zinc ions being both excluded and included as being associated with binding sites. As stated above, it is common for the asymmetric unit of a PDB file to contain multiple copies of the biomolecule of interest as a result of crystallization, but once the `correct' assembly is chosen, these duplicated zinc atoms will be absent from the final structure. Conversely, using the full biological assembly rather than just the raw asymmetric unit coordinates of the PDB is crucial when the zinc atom is present at an interface between chains. In the asymmetric unit, there may be a single residue coordinating with the ion - if symmetry were not considered, such a model would be discarded by the ZincBind algorithm as a salt.

\subsection{Zinc Binding Sites with High Representation}

The 28,667 metal atoms, for which binding site information is stored, are part of a total of 24,992 zinc binding sites in ZincBind. After clustering the proteins at 90\% sequence identity and then clustering the binding sites as described above, there are 7,489 unique zinc binding sites in the database. The binding site with the most copies is from carbonic anhydrase (693 copies), a catalytic serum protein and, as already noted, the first known zinc binding protein. This is followed by a nitric oxide synthase zinc binding site (285 copies), an interface site between two chains, and then JMJD2D (266 copies), a lysine-specific demethylase. 4,223 zinc binding sites are currently unique in that they have only one structure.

For each cluster of equivalent zinc binding sites, the best resolution structure is chosen to provide a single site which is flagged as the `representative' for that cluster.

\subsection{Liganding Residues}

The binding residues that dominate zinc binding sites are well established: cysteine, histidine, and the acidic residues aspartate and glutamate \note{Cite}. This is supported by the data in ZincBind. There are a total of 109,363 liganding residues in ZincBind, of which those four residue types, together with water, comprise 92.6\% of all zinc-liganding residues. Note, however, that this considers every binding site in the database. When non-redundant sites are studied (i.e.\ only one site per cluster thereby removing the bias towards more intensely studied proteins), these five comprise a slightly smaller percentage of zinc-liganding residues (91.1\%). This suggests that the binding sites most frequently appearing in the PDB show slightly less variation than a more representative sampling.

If the binding residues' single letter codes are combined to give an overall `signature' of the binding site, C4 (four cysteine residues) is the most prevalent, with 1,129 of the 7,489 unique binding sites having this arrangement of residues - followed closely by C3H1, with 931. That the most common signature makes up just 15.1\% of the total is indicative of the relatively high diversity in such signatures. Between them, the top ten residue signatures account for just 57.6\% of the total.

Of the 21,810 redundant binding sites that contain just one zinc atom, and which come from structures with resolutions better than 3\AA, the most common mode of coordination is via four liganding atoms: 14,702 examples (67.4\%). 3-coordination and 5-coordination have similar prevalences: 2,027 (9.4\%) and 3,274 (15.2\%) respectively. 

This same subset of binding sites can be used to investigate liganding atom distances. Nitrogen and sulphur atoms both have characteristic distances with tight distributions: $2.12\pm0.19$\AA\ and $2.33\pm0.12$\AA\ respectively. Oxygen however as a much wider distribution, as it can be provided by either of the carboxylate oxygens of the acidic side chains, or from water. Its average distance to zinc is $2.31\pm0.54$\AA.

\subsection{Co-active Binding Sites}

In some cases multiple metals act in concert to form a single functional unit. Such sites are generally referred to as co-active binding sites in the literature (or `co-catalytic' where the site is known to have a catalytic function). Here, such sites are defined as those instances where a single residue is liganded to more than one metal, according to the criteria defined above. The metals are grouped into a single site as described in the methods.

In ZincBind, 3,182 from the total of 24,992 zinc binding sites (12.7\%) contain multiple metals - 2,754 contain two metals, 379 contain three, 36 contain four, ten contain five, and three zinc binding sites contain six metals - though two of these are from a synthetic construct.

These multi-metal sites account for all of the non-zinc metals in the ZincBind database. While the term `co-catalytic' is sometimes used interchangeably with `co-active', only 2661 (83.6\%) are derived from an enzymatic protein (defined here as a protein name ending in \emph{--ase}). However this compares with just 61.1\% of all zinc-only binding sites that are enzymatic. A Fisher exact test showed the difference to be significant ($p<0.00001$).