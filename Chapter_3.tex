%%%% MACRO DEFINITION %%%%

\providecommand{\pvivax}{P.~vivax}
\providecommand{\pfalciparum}{P.~falciparum}
\providecommand{\cterm}{C-terminus}
\providecommand{\nterm}{N-terminus}

\providecommand{\e}[1]{\ensuremath{\times 10^{#1}}}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}

\providecommand{\refimage}[1]{\figurename~\ref{fig:#1}}

%TC:macro \note [ignore]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%													BEGIN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{ZincBind - The Database of Zinc Binding Sites} % Write in your own chapter title
\label{Chapter3}
\lhead{Chapter 3. \emph{ZincBind - The Database of Zinc Binding Sites}} % Write in your own chapter title to set the page header

This project is an attempt to develop novel means of predicting Zinc Binding Sites using the known properties of previously identified Zinc Binding Sites. As such, the initial step was to create a dataset of these already known sites.

This is an undertaking that has been performed previously - several times (see Chapter 1). One of the primary reasons that the effort has been duplicated so many times is because in none of the previous dataset generations did the authors make their data publicly available in an easy-to-use resource. Therefore from the very beginning of this project, the intention was always to not \emph{just} create this dataset of Zinc Binding Sites, but to make this database publicly available via a web resource, that would be continually updated with new sites as they become available.

This chapter will describe the creation of that dataset, and the web application that offers users access to the data - ZincBind.

\section{Data Generation}

ZincBind uses as its primary data source the Protein Databank \note{cite}. This contains hundreds of thousands of protein structures, a subset of which contain zinc atoms and which can be inspected to see if a zinc binding site can be identified.

The RCSB web services allow a user to query the entire databank by, among other things, the chemical formulae of its small molecules. The PDB IDs of all zinc atom containing structures can therefore be obtained by issuing a request to these web services for a \verb|ChemCompFormulaQuery| with the formula \verb|Zn|.

If the dataset is being created from scratch, each of these PDB IDs is iterated through in turn to look for zinc binding sites. If the dataset is merely being updated with new structures, only those IDs that don't already exist in the database are used.

\subsection{Structure Inspection}

The algorithm iterates through each PDB code and for each attempts to determine what zinc binding sites are present, if any, and saves the relevant objects to the database once its analysis is complete. Each PDB ID is analysed within a single database transaction, meaning that the SQL statements are built up by Django throughout the analysis and then executed all at once at the end of each PDB ID analysis. This has two benefits. Firstly, it makes the whole process much faster - there are database records for each atom in the binding site, so opening up database connections, creating a record, and closing the connection multiple times per structure is much more time consuming than just doing that once at the end. Secondly, and more importantly, if the program is interrupted in the middle of building a database, it will essentially rollback to the last fully processed PDB, rather than saving records for half-processed PDBs which could cause errors when the program is restarted.

The structures are requested from the RCSB web servers in the .cif file format. This, and all subsequent structure parsing and analysis, are abstracted into the atomium Python library (see Appendix A).

The first processing step with the obtained and parsed structure, is to generate a biological assembly. The raw coordinates of the PDB structure contain the `asymmetric unit', which is often not the way the chains are arranged outside of the crystallisation experiment. Each PDB structure contains a list of possible biological assemblies that can be created from the chains in the asymmetric unit to make a more biologically realistic structure, and each is associated with a list of transformation matrices and calculated metrics. The delta free energy of the assemblies are used to rank them, and the lowest delta free energy assembly that still contains zinc is selected as the `real' biological assembly.

This step is critical. While asymmetric units are perfectly suitable if you are merely concerned with intra-chain features, they are often unsuitable for examining the interfaces between chains. Since many zinc binding sites are between chains, relying on asymmetric units would produce data that is not particularly meaningful.

The algorithm then checks that the resultant structure is usable, and is not just alpha carbons as some older structures are. If it is a `skeleton structure', the zinc atom(s) in that structure are saved to the database with an annotation explaining that they don't have a binding site because the PDB was unusable. Note that this is the case whenever a zinc atom is rejected - it is still saved to the database with an explanatory annotation, because by doing this \emph{every} zinc atom in the Protein Data Bank can be accounted for in ZincBind. If this were not done, and a user tried to find a particular zinc atom from the data bank in ZincBind which had not been assigned a binding site, that user would have no way of knowing if the zinc atom was absent because ZincBind had not examined that PDB, or if it was absent because a binding site could not be assigned to it.

Any zinc atoms that are in the asymmetric unit but not the biological assembly (common in cases where the asymmetric unit is just the biological assembly repeated multiple times) are also saved to the database without a binding site, with an explanatory explanation as to why it has none, for the same reason.

Having assembled the correct structure, the algorithm then identifies all metals in the model, using a predefined list of elements. The atoms which coordinate each of these metals, if any, are determined by identifying all atoms within 3~{\AA}ngstr\"{o}ms of the metal, which aren't carbon or hydrogen, and which don't have a bond angle of less than 60$^\circ$ with a closer atom. The residues or small molecules that these belong to constitute the liganding residues, and each liganding atom is flagged as such.

Because metal binding sites can consist of multiple metals acting as a single functional unit \note{Cite!}, the metals need to be clustered in this way. This is done by assigning two metals to the same cluster if they have a liganding residue in common. At this juncture, there will be a number of substructures identified, each of which contains one or more metals and zero or more liganding residues. The ones with no zinc in them at all are discarded, as they are not zinc binding sites - it was necessary to examine them because until liganding residues are assigned there is no way of knowing whether they are co-functional with a zinc atom, but now these have been assigned, the metal atoms that have no interaction with zinc are not needed. Also discarded are those clusters which contain fewer than two liganding protein residues, or fewer than three liganding protein atoms. Many zinc atoms in a structure will be simply zinc salts present in the crystallographic experiment, and by providing this threshold for interaction with an actual protein, these functionally irrelevant zincs can be excluded. Note that a zinc atom that has only two binding residues will therefore be valid only if one of those residues provides at least two liganding atoms, such as via a carboxylate group.

Again, those zinc atoms which are excluded at this stage are given an annotation explaining the reason.

Those clusters remaining are saved to the database as zinc binding sites, with records for metals, residues, residue atoms, and the site itself. Also saved are records for the protein chains that the residues are a part of, along with their complete sequence (as reported in the structure annotation, not the sequence of residues in the model, which may have missing residues).

\subsection{Equivalent Sites}

The database as it stands at this point in the algorithm will be a list of zinc binding sites, where each site is considered distinct and separate from all others. This is somewhat misleading, as many proteins appear in the Protein Data Bank several times, and so the binding site(s) in those structures will appear in ZincBind several times. The binding site in (for example) Carbonic Anhydrase will appear in ZincBind many hundreds of times, yet each of these records refer to the same biological unit.

To account for this, ZincBind clusters binding sites into equivalent sites. The first step is to cluster the zinc binding chains that were saved as part of the earlier generation process into clusters on 90\% sequence identity, using the program CD-HIT \note{cite}. It is assumed that chains in a chain cluster are functionally equivalent.

The binding sites themselves are then clustered using these chain clusters. Two zinc binding sites are assigned to the same cluster if (1) they are associated with the same chain cluster(s), (2) they have the same residue names in the same order, and (3) their surrounding residue names are the same. These latter two steps are important to ensure that chains with two or more zinc binding sites along them don't have those binding sites incorrectly assigned to the same cluster.

Finally, one site in each cluster is flagged as being `representative'. This is so that analysis that requires only one zinc binding site from each cluster is easier, and the site chosen is the site from the lowest resolution structure.

\subsection{The ZincBind Web Resource}

As already noted, the creation of this dataset was intended to serve both as the primary dataset of this project, and as a publicly available resource.

This resource is called ZincBind, and is accessible at \url{zincbind.bioinf.org.uk}. The website is created with Django, a Python web framework and Object Relational Management system.

The web frontend is designed with a responsive, mobile-first layout that adapts to different screen sizes, and modern JavaScript and Test Driven Development practices.

The home page contains a short, clear statement of what ZincBind is (a ``database of zinc binding sites, automatically generated from the Protein Data Bank") as well as a brief overview of its key metrics - number of unique binding sites, total number of binding sites, and the number of PDB files the sites are derived from.

Searching of the database can be done in one of three ways. Firstly, from the home page, the user can enter a search term that will be used to search multiple PDB fields at once - title, PDB code, classification etc. This is for users who just want to find entries that have any relation to a given term at all. Secondly, the user can navigate to the Advanced Search page, where they can specify a more precise search by one or more fields. This also allows searching by numeric cutoffs, such as for PDBs below a certain resolution or deposited after a certain date. Thirdly, they can provide a sequence and BLAST search the database. This uses the NCBI blastp binary on the backend, whose JSON output is processed by Django.

The search results for the first two modes of searching are returned as a list of matching PDBs, with binding sites nested within them. Both the PDB and the sites themselves are clickable and will take the user to the page for that entitiy. Search results can be sorted by a variety of metrics, and are paginated to 25 results per page.

PDB pages represent PDB records. They provide basic information for that PDB, as well as overviews of the zinc content of that PDB. The zincs associated with a binding site are listed as clickable links, while those without a binding site are listed along with their omission reason. Finally, there is a 3D maniplatable view of the PDB with all of its zinc binding sites. This uses the NGL JavaScript library.

The binding site pages contain more detail for that specific binding site, such as its mode of coordination, and links to equivalent sites in the same cluster. There is also a 3D manipualtable model of the binding site on this page, zoomed in to the specific site and with selectable individual residues and metals.

ZincBind also has a page that gives an overview of the dataset as a whole. This contains charts for residue dsitribution, experimental methods, residue codes, resolution, species frequency, and PDB classification. There are also buttons for downloading the entire dataset in either JSON or SQlite, a link to browse the entire dataset PDB by PDB, and a link to the API.

ZincBind's API is a web browsable REST API, created using the Django Rest Framework. Web browsability means that results will be returned as HTML if requests are sent using a browser, and JSON otherwise. The API can be used to get JSON represtations of object sets, individual objects, and to search the databse using all the same parameters as the browser search tool.

Finally, ZincBind has a help page, structured as a series of questions that a user may have.
