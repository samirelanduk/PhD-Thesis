%%%% MACRO DEFINITION %%%%

\providecommand{\pvivax}{P.~vivax}
\providecommand{\pfalciparum}{P.~falciparum}
\providecommand{\cterm}{C-terminus}
\providecommand{\nterm}{N-terminus}

\providecommand{\e}[1]{\ensuremath{\times 10^{#1}}}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}

\providecommand{\refimage}[1]{\figurename~\ref{fig:#1}}

%TC:macro \note [ignore]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%													BEGIN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Predicting Zinc Binding Sites in Structures} % Write in your own chapter title
\label{Chapter4}
\lhead{Chapter 4. \emph{Predicting Zinc Binding Sites in Structures}} % Write in your own chapter title to set the page header

The aim of this component of the PhD is to create a system which ultimately is quite simple --- it would take as its input a protein structure, and output a list of zero or more residue combinations which are predicted to form a zinc binding site, with an accompanying probability.

This system is a machine learning system - it uses binary classifiers trained on the large dataset of zinc binding sites described in the previous chapter which `learn' what zinc binding sites look like form that data.

This chapter will describe the approach taken to solving this problem, the models created, the archietcture of the system from the user's point of view, and how the models are accessed and used.


\subsection{From Chapter 2}

The inputs and outputs are more open to interpretation however. So far I have framed the problem in terms of entire proteins - the input is an entire protein structure or an entire protein sequence, and the output is the number and location of the zinc binding site(s) that may be present. However this is difficult to translate into machine learning concepts, which is best suited to mapping input objects to either discrete classes or single continuous values. It is not really practical to represent `the number and location of the zinc binding site(s) that may be present' as a category or a number, so instead the problem will be re-framed so that the input is some sub-component of the protein, and the output is a binary class - `yes that component is a zinc binding region` or `no that region is not a zinc binding region'. The problem is therefore a classification problem, with two classes. When a protein is given, it is broken into its various components, each component is run through the model which predicts it as either zinc binding or not zinc binding, and then the net result for the protein as a whole is the list of components that are predicted as zinc binding.

But what should be the components? What inputs will actually be passed to the model? For protein structures, one obvious possibility is simply location in space - every point within the three-dimensional structure is taken (in some specified resolution grid) and passed to the model as an input, which assigns that location a predictive label. This would be comprehensive but time consuming, as there would be many points to check - the number of points could be limited to the protein surface, but there would still be a lot. Another possible means of breaking the structure into components would be to take all the combinations of residues that are known to bind zinc, and treat these as inputs - there could again be very many of these, but fewer than if every point in space were checked. For sequences, there is no equivalent to checking every point in space, as this information is obviously not available and residues nearby in space are not necessarily nearby in sequence. However using the combinations of zinc binding residues is still applicable to sequences.


\subsection{(From chapter 3) Web-Based Prediction}

The ZincBind website has a webpage through which users may submit `jobs' for prediction - they can upload either a structure file or a sequence, and the server will analyse them and try to ascertain if they contain any zinc binding residues.

The details of these predictive algorithms will be explained in the following chapters, but from a web development perspective, the overall architecture of how these jobs are submitted and presented to the user can be outlined here.

On the prediction page, the user is prompted to provide the representation of a protein - either as a structure file, a sequence file, or a FASTA sequence pasted in. This is done via a HTML form, and as soon as the page loads a hidden input with the job ID is generated. This is just the current time in milliseconds, making it extremely unlikely that any two jobs would have the same ID given the niche area of Biology the tool is for.

As soon as the data is given, and before the form is actually submitted, the data in question is stored to the browser's local storage using the job ID that was generated when the page loaded. This is because on the next page, this data will be used to give the user a visualisation of the data in question, and downloading it from the server when it has just been uploaded from the local machine would be a waste of bandwidth.

Once the user submits the form, the server receives the datafile, and job ID, and the django application starts the analysis process. It creates a folder in the jobs directory with the job ID's name, puts the uploaded file there, and then runs the predict.py script on it. This script is a general purpose script which takes any submitted file, and calls other predictive tools created in this PhD on it. Crucially though, this is called as an asynchronous process, so the request/response cycle doesn't have to wait for it to complete. Once the process is started, the user is redirected to the page for this particular job.

This page uses the data in local storage to show the user what they have submitted (using the NGL protein viewer for structures \note{and for sequences?}) along with a suitable `this protein is being searched' animation. The page the constantly polls the server with AJAX requests for progress updates on the job (with ever increasing periods of time between requests). The script writes its progress to a log file, which the server answers the AJAX requests with - these are then formatted and presented to the user.

The page receives the log text and outputs it to the screen in a div element, albeit with some modifications. Each line is wrapped in its own div elements to make them appear on their own line, and lines which were indented in the log file are given a particular CSS class to make them indented on screen (as tabs are ignored in HTML).

Lines which begin with an underscore in the log file are not printed to the screen, as these are the lines which contain the identified binding sites. The lines contain, space-separated, the family of the predicted binding site, the residue name and ID of the residues identified, and the `score' they have obtained. These are used to create clickable boxes for each predicted site in the HTML, and to assign each an NGL selection string so that when they are clicked, the 3D view of the protein zooms in to that part of the protein and displays their side chains.

\note{Explain how found binding sites are shown.}



\section{Families}

The first consideration when creating a machine learning classifier is the features that will be used to represent the inputs. Classifiers take their inputs as a vector of numbers and then try to assign the vector to one of two (in the case of binary classifiers) categories. Because the aim here is not just to label an entire protein as either zinc binfing or not zinc binding, but rather to identify the actual zinc binding residues, the proteins themselves are not the inputs - potential zinc binding sites within the protein are.

The main approach is to use combinations of residues as the inputs. That is all plausible combinations of residues will be looked at in turn, turned into a vector, and passed to the model.

Rather than create a single model, the decision was taken early on to create a model for each family. That is, there is a model which looks at sets of three histidines and tries to determine if it is a H3 binding site, a model which looks at sets of four cysteines and tries to determine if it is a C4 binding site, and so on. The main reason for this is that the geometric spacing of residues varies widely between different families, but not within families, which should allow a model to more easily learn what constitutes a likely binding site of a particular family. \note{Definitely need to show this in chapter 3!}

Another advnatage of this approach is a purely practical one. All the possible H3 binding sites in a protein are found by taking all combinations of three histidine residues, and while the combinatorics of this can lead to large numbers of potential sites to check, it is vastly smaller than the combinations of \emph{all} residues that would need to be checked if the model was suppoed to look for a generic zinc binding sites --- an infeasible task for all but the smallest of proteins.

\section{Datasets}
A training dataset was created for each family, using the ZincBindDB API. For each family, all zinc binding sites of that family, belonging to PDBs with a resolution equal to or better than 2 {\AA} were identified --- this quality cutoff being used so that the interatomic distances used in the making of the dataset could be relied upon.

For each site, the PDB file was downloaded.


\section{Old}


Before applying machine learning methods to the dataset, it is worth stopping to see if there are any straightforward identifiable geometric patterns that occur in the zinc binding stuctures gathered, which might be used as templates to search in unknown structures.

There is a wide variety of different binding modes and residue composition, as has been shown, so it is not at first apparent that there should be any usable geometric templates that can be extracted from these. However ZincBind divides the binding sites among families, each with their own residue makeup, and it seems much more plausible that there may be consistent within families. That is, while there may not be a single `zinc binding pattern', there may be a `H3' pattern for example, or a `C2H2' pattern.

Specifically, in this chapter I am interested in patterns of alpha and beta carbons, and the binding sites will be examined in terms of the geometry of these atoms. There are two primary reasons for this:

\begin{enumerate}
   \item The primary use case for searching through protein structures looking for zinc binding patterns is for when the structure is an apo-structure - without zinc. The actual liganding `tips' of liganding residues would be expected to vary more markedly in position than the alpha and beta carbons, which are more constrained by the overall fold of the protein \note{Cite!}.
   \item All residues contain alpha carbons, and all but one contain beta carbons. This means that essentially all residues can be searched for the resultant pattern. While this is not especially useful for the specific use case of finding native zinc binding sites, it \emph{is} useful for zinc binding site engineering. The pattern search could identify all residues which fit a given pattern, and if the residue identities also match it can be flagged as a possible zinc binding site, and if they don't, it can be flagged as a site which could feasibly be mutated to become one.
\end{enumerate}

\subsection{Profile Generation}

The initial step is to go through the ZincBind dataset and create a `profile' for each family. As some of the smaller families are quite esoteric, with large numbers of residues and metals, I decided to limit the scan for the smaller, more highly represented families. Specifically, the initial families were H3 (chosen because carbonic anhydrase is in this family, which is a frequent target of protein engineering), C4 (the most common family), C2H2, and C3H1 (both common families, important in zinc fingers).

Limiting to families which generally ligate a single zinc, rather than coactive binding sites, is important as there would be more constraints on residue position if they are all clustered around a single centre.

For each family, all sites are examined providing (1) their resolution is better than 2.5 ~{\AA}, (2) they only have a single metal, and (3) they ligate using side chain atoms \note{Not at time of writing!}.

The key attributes to determine for any given site are thos eattributes which would be used to actually search a novel structure. This means that the distribution of distances between residue atoms and the metal atom, however interesting, are irrelevant for these purposes because the structures being searched will not have metals present. That leaves the distances between the alpha and beta carbons themselves.

The number of measurements needed for a given binding site will increase with the number of residues, because all combinations need to be considered. For three residue sites such as H3, there are three measurements for the alpha carbons (CA1-CA2, CA2-CA3, CA1-CA3) and three for the beta carbons (CB1-CB2, CB2-CB3, CB1-CB3), for a total of six measurements. For four residue sites, there are six alpha measurements and six beta measurements \note{Give combinations formula explanation}.

This requires a certain consistency in which residues are labelled as 1, 2 etc. In this system, the residues of a given type are ordered by alpha carbon distance to the metal, and numbered accordingly.